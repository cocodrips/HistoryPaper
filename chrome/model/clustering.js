// Generated by CoffeeScript 1.6.3
(function() {
  this.Clustering = (function() {
    function Clustering(histories) {
      var clusterNum, i, _i;
      this.searchWords = null;
      this.histories = this.createHistoryObject(histories);
      clusterNum = this.calcClusterNum();
      this.clusters = [];
      for (i = _i = 0; 0 <= clusterNum ? _i < clusterNum : _i > clusterNum; i = 0 <= clusterNum ? ++_i : --_i) {
        this.clusters[i] = [];
      }
    }

    Clustering.prototype.getClusteredHistories = function() {
      var i, kmeans, obj, objs, _i, _len;
      this.setWords2Histories();
      this.setKeys2Histories();
      kmeans = new Kmeans(this.histories, 10);
      objs = kmeans.start();
      for (i = _i = 0, _len = objs.length; _i < _len; i = ++_i) {
        obj = objs[i];
        this.clusters[obj.clusterId].push(i);
      }
      return objs;
    };

    Clustering.prototype.createHistoryObject = function(histories) {
      var history, historyObjs, i, k, obj, v, _i, _len;
      histories = this.removeSearchHistory(histories);
      historyObjs = [];
      for (i = _i = 0, _len = histories.length; _i < _len; i = ++_i) {
        history = histories[i];
        obj = new HistoryObject();
        for (k in history) {
          v = history[k];
          obj[k] = v;
        }
        historyObjs[i] = obj;
      }
      return historyObjs;
    };

    Clustering.prototype.getClusterHistories = function(clusterId) {
      var histories, i, _i, _len, _ref;
      histories = [];
      _ref = this.clusters[clusterId];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        histories[i] = this.histories[i];
      }
      return histories;
    };

    Clustering.prototype.setKeys2Histories = function() {
      var history, k, keywords, topKeywords, _i, _j, _len, _len1, _ref, _results;
      topKeywords = this.selectTopKeywords(100);
      _ref = this.histories;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        history = _ref[_i];
        keywords = {};
        for (_j = 0, _len1 = topKeywords.length; _j < _len1; _j++) {
          k = topKeywords[_j];
          if (_.contains(history.words, k)) {
            if (keywords[k]) {
              keywords[k]++;
            } else {
              keywords[k] = 1;
            }
          } else {
            keywords[k] = 0;
          }
        }
        _results.push(history.coordinate = keywords);
      }
      return _results;
    };

    Clustering.prototype.setWords2Histories = function() {
      var history, segmenter, _i, _len, _ref, _results;
      _ref = this.histories;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        history = _ref[_i];
        segmenter = new TinySegmenter();
        _results.push(history.words = segmenter.segment(history.title));
      }
      return _results;
    };

    Clustering.prototype.calcClusterNum = function() {
      return Math.min(this.histories.length, 20);
    };

    Clustering.prototype.removeSearchHistory = function(histories) {
      var h, history, q, query, words, _i, _j, _len, _len1;
      words = {};
      h = [];
      for (_i = 0, _len = histories.length; _i < _len; _i++) {
        history = histories[_i];
        if (history.url.indexOf("https://www.google.co.jp/search?") === -1) {
          h.push(history);
        }
        q = history.url.match(/\?q=.*?\&/);
        if (!q) {
          continue;
        }
        try {
          q = decodeURI(q[0]).replace(/\?q=(.*?)\&/, '$1');
          q = q.split(/[\s,\+]+/);
          for (_j = 0, _len1 = q.length; _j < _len1; _j++) {
            query = q[_j];
            if (!words[query]) {
              words[query] = 1;
            } else {
              words[query] += 1;
            }
          }
        } catch (_error) {}
      }
      this.searchWords = words;
      return h;
    };

    Clustering.prototype.selectTopKeywords = function(n) {
      var data, history, i, keyword, keywords, topKeywords, word, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      data = [];
      _ref = this.histories;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        history = _ref[_i];
        _ref1 = history.words;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          word = _ref1[_j];
          word = $.trim(word);
          if (data[word]) {
            data[word]++;
          } else {
            data[word] = 1;
          }
        }
      }
      keywords = this.sortByValue(data, true);
      topKeywords = [];
      i = 0;
      for (_k = 0, _len2 = keywords.length; _k < _len2; _k++) {
        keyword = keywords[_k];
        if (!stopwords[keyword]) {
          topKeywords.push(keyword);
          if (++i >= n) {
            break;
          }
        }
      }
      return topKeywords;
    };

    Clustering.prototype.extractKeyword = function(history) {
      var keywords, word, _i, _len, _ref, _results;
      keywords = [];
      _ref = history.words;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        word = _ref[_i];
        if (this.isKeyword(word)) {
          _results.push(keywords.push(word));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Clustering.prototype.isKeyword = function(word) {
      if (word.length === 1) {
        return false;
      }
      if (stopwords[word]) {
        return false;
      }
      return true;
    };

    Clustering.prototype.sortByValue = function(data, reverse) {
      var e, k, l, v, z, _i, _len;
      z = [];
      for (k in data) {
        v = data[k];
        z.push([v, k]);
      }
      z.sort(function(a, b) {
        if (a[0] < b[0]) {
          return -1;
        }
        if (a[0] > b[0]) {
          return 1;
        }
        return 0;
      });
      if (reverse) {
        z.reverse();
      }
      l = [];
      for (_i = 0, _len = z.length; _i < _len; _i++) {
        e = z[_i];
        l.push(e[1]);
      }
      return l;
    };

    return Clustering;

  })();

}).call(this);
