// Generated by CoffeeScript 1.6.3
(function() {
  var Centroid, ClusteringObj;

  ClusteringObj = (function() {
    function ClusteringObj(coordinate, clusterId) {
      this.coordinate = coordinate;
      this.clusterId = clusterId;
    }

    return ClusteringObj;

  })();

  Centroid = (function() {
    function Centroid(keys) {
      var k, _i, _len;
      this.num = 0;
      this.coordinate = {};
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        this.coordinate[k] = 0;
      }
    }

    return Centroid;

  })();

  this.Kmeans = (function() {
    function Kmeans(coordinates, k) {
      var coordinate, i, _i, _len;
      this.k = k;
      this.objKeys = Object.keys(coordinates[0]);
      this.dim = this.objKeys.length;
      this.objs = [];
      for (i = _i = 0, _len = coordinates.length; _i < _len; i = ++_i) {
        coordinate = coordinates[i];
        this.objs[i] = new ClusteringObj(coordinate, i % k);
      }
    }

    Kmeans.prototype.start = function() {
      var centroids, _, _i;
      for (_ = _i = 0; _i < 10; _ = ++_i) {
        centroids = this.calcCentroids();
        this.updateClusterId(centroids);
      }
      return this.objs;
    };

    Kmeans.prototype.calcCentroids = function() {
      var c, centroids, k, obj, v, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
      centroids = [];
      for (c = _i = 0, _ref = this.k; 0 <= _ref ? _i < _ref : _i > _ref; c = 0 <= _ref ? ++_i : --_i) {
        centroids[c] = new Centroid(this.objKeys);
      }
      _ref1 = this.objs;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        obj = _ref1[_j];
        centroids[obj.clusterId].num += 1;
        _ref2 = obj.coordinate;
        for (k in _ref2) {
          v = _ref2[k];
          centroids[obj.clusterId].coordinate[k] += v;
        }
      }
      for (c = _k = 0, _ref3 = this.k; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; c = 0 <= _ref3 ? ++_k : --_k) {
        _ref4 = this.objKeys;
        for (_l = 0, _len1 = _ref4.length; _l < _len1; _l++) {
          k = _ref4[_l];
          centroids[c].coordinate[k] /= centroids[c].num;
        }
      }
      return centroids;
    };

    Kmeans.prototype.updateClusterId = function(centroids) {
      var INF, c, dist, min, min_dist, obj, _i, _j, _len, _ref, _ref1, _results;
      INF = 100000000000;
      _ref = this.objs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        min = null;
        min_dist = INF;
        for (c = _j = 0, _ref1 = this.k; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
          dist = this.distance(obj.coordinate, centroids[c].coordinate);
          if (dist < min_dist) {
            min_dist = dist;
            min = c;
          }
        }
        _results.push(obj.clusterId = min);
      }
      return _results;
    };

    Kmeans.prototype.distance = function(a, b) {
      var k, sum;
      sum = 0;
      for (k in a) {
        sum += Math.pow(a[k] - b[k], 2);
      }
      return Math.sqrt(sum);
    };

    return Kmeans;

  })();

}).call(this);
