// Generated by CoffeeScript 1.6.3
(function() {
  var DEFAULT_HEIGHT, DEFAULT_WIDTH, RectType, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Page = (function() {
    function Page(priority, type, name) {
      this.priority = priority;
      this.type = type;
      this.name = name != null ? name : null;
      this.originalPriority = this.priority;
      this.rect = new Rect();
      this.id = Math.random();
      this.idealArea = 0;
    }

    Page.prototype.isEqual = function(other) {
      if (other.id) {
        return this.id === other.id;
      } else {
        return false;
      }
    };

    return Page;

  })();

  this.Rect = (function() {
    function Rect(x, y, width, height) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.width = width != null ? width : 0;
      this.height = height != null ? height : 0;
    }

    Rect.prototype.isEqual = function(other) {
      return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
    };

    Rect.prototype.copy = function() {
      return new Rect(this.x, this.y, this.width, this.height);
    };

    Rect.prototype.area = function() {
      return this.width * this.height;
    };

    Rect.prototype.ratio = function() {
      return this.width / this.height;
    };

    Rect.prototype.vec4 = function() {
      return [this.x, this.y, this.width, this.height];
    };

    return Rect;

  })();

  DEFAULT_WIDTH = 500;

  DEFAULT_HEIGHT = 500;

  this.Base = (function() {
    function Base(data, pageSets, width, height, minWidth, minHeight) {
      if (data == null) {
        data = null;
      }
      this.pageSets = pageSets != null ? pageSets : null;
      this.width = width != null ? width : DEFAULT_WIDTH;
      this.height = height != null ? height : DEFAULT_HEIGHT;
      this.minWidth = minWidth != null ? minWidth : 100;
      this.minHeight = minHeight != null ? minHeight : 60;
      if (!pageSets) {
        this.pageSets = this.createPageSets(data);
      }
      this.layoutOrder = [];
    }

    Base.prototype.createPageSets = function(data) {
      var d;
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          d = data[_i];
          _results.push(new Page(d.priority, d.type, d.name));
        }
        return _results;
      })();
    };

    Base.prototype.setIdealArea = function(pageSets) {
      var area, prioritySum;
      prioritySum = pageUtils.prioritySum(pageSets);
      area = this.width * this.height;
      return this.calcIdealArea(pageSets, area, prioritySum);
    };

    Base.prototype.calcIdealArea = function(pageSets, area, prioritySum) {
      var pageSet, _i, _len, _results;
      if (!pageUtils.isGroup(pageSets)) {
        return pageSets.idealArea = pageSets.priority * area / prioritySum;
      } else {
        _results = [];
        for (_i = 0, _len = pageSets.length; _i < _len; _i++) {
          pageSet = pageSets[_i];
          _results.push(this.calcIdealArea(pageSet, area, prioritySum));
        }
        return _results;
      }
    };

    Base.prototype.newSets = function(pageSets, targets) {
      var isSame, pageSet, sets, target, _i, _j, _k, _len, _len1, _len2;
      if (!pageUtils.isGroup(target)) {
        targets = [targets];
      }
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        this.layoutOrder.push(target);
      }
      sets = [];
      for (_j = 0, _len1 = pageSets.length; _j < _len1; _j++) {
        pageSet = pageSets[_j];
        isSame = false;
        for (_k = 0, _len2 = targets.length; _k < _len2; _k++) {
          target = targets[_k];
          if (target === pageSet) {
            isSame = true;
            break;
          }
        }
        if (!isSame) {
          sets.push(pageSet);
        }
      }
      return sets;
    };

    return Base;

  })();

  this.GreedyLayout = (function(_super) {
    __extends(GreedyLayout, _super);

    function GreedyLayout() {
      _ref = GreedyLayout.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    GreedyLayout.prototype.layout = function() {
      var groupSets;
      pageUtils.sort(this.pageSets);
      groupSets = pageUtils.grouping(this.pageSets);
      pageUtils.deformPriorities(groupSets, this.width * this.height, this.minWidth, this.minHeight);
      this.setIdealArea(groupSets);
      pageUtils.sort(groupSets, true, pageUtils.avg);
      return this.arrange(groupSets, new Rect(0, 0, this.width, this.height));
    };

    GreedyLayout.prototype.arrange = function(pageSets, rect) {
      if (pageSets.length < 1) {

      } else if (pageSets.length < 3) {
        return this.split(pageSets, rect);
      } else {
        return this.arrangeTopLeft(pageSets, rect);
      }
    };

    GreedyLayout.prototype.split = function(pageSets, rect) {
      var diff, horizontalRect, horizontalRects, i, isVertical, minDiff, ratioType, verticalRect, verticalRects, _i, _j, _len, _len1;
      verticalRects = this.splitPageSetsArea(pageSets, rect, true, false);
      diff = 0;
      for (i = _i = 0, _len = verticalRects.length; _i < _len; i = ++_i) {
        verticalRect = verticalRects[i];
        ratioType = pageUtils.isGroup(pageSets[i]) ? pageSets[i][0].type : pageSets[i].type;
        diff += pageUtils.diffRatio(verticalRect, ratioType);
      }
      minDiff = diff;
      isVertical = true;
      horizontalRects = this.splitPageSetsArea(pageSets, rect, false, false);
      diff = 0;
      for (i = _j = 0, _len1 = horizontalRects.length; _j < _len1; i = ++_j) {
        horizontalRect = horizontalRects[i];
        ratioType = pageUtils.isGroup(pageSets[i]) ? pageSets[i][0].type : pageSets[i].type;
        diff += pageUtils.diffRatio(horizontalRect, ratioType);
      }
      if (diff < minDiff) {
        isVertical = false;
      }
      return this.splitPageSetsArea(pageSets, rect, isVertical, true);
    };

    GreedyLayout.prototype.arrangeTopLeft = function(pageSets, rect) {
      var bottomSetsRect, d, idealArea, isVertical, minDiff, optimalSets, optimalTopRect, rectType, remainingRect, remainingSets, target, tops, width, _i, _j, _len, _len1, _ref1;
      tops = pageUtils.max(pageSets);
      remainingSets = this.newSets(pageSets, tops);
      optimalTopRect = null;
      optimalSets = [];
      minDiff = 100000000000000;
      idealArea = pageUtils.idealSum(tops);
      isVertical = false;
      _ref1 = rectTypes[tops[0].type];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        rectType = _ref1[_i];
        if (tops.length < rectType.minAlign) {
          continue;
        }
        d = this.fixTopLeftRect(remainingSets, rect, idealArea, rectType.ratio / tops.length);
        if (d.diff < minDiff) {
          minDiff = d.diff;
          optimalTopRect = d.topRect;
          optimalSets = d.pageSets;
          isVertical = true;
        }
        d = this.fixTopLeftRect(remainingSets, rect, idealArea, rectType.ratio * tops.length);
        if (d.diff < minDiff) {
          minDiff = d.diff;
          optimalTopRect = d.topRect;
          optimalSets = d.pageSets;
        }
      }
      width = (pageUtils.idealSum(tops) + pageUtils.idealSum(optimalSets)) / rect.height;
      optimalTopRect.height = optimalTopRect.area() / width;
      optimalTopRect.width = width;
      bottomSetsRect = this.bottomRect(rect, optimalTopRect);
      remainingRect = rect.copy();
      remainingRect.x += width;
      remainingRect.width -= width;
      for (_j = 0, _len1 = optimalSets.length; _j < _len1; _j++) {
        target = optimalSets[_j];
        remainingSets = this.newSets(remainingSets, target);
      }
      this.split(tops, optimalTopRect);
      this.arrange(optimalSets, bottomSetsRect);
      return this.arrange(remainingSets, remainingRect);
    };

    GreedyLayout.prototype.fixTopLeftRect = function(remainingSets, parentRect, idealArea, ratio) {
      var bottomRect, diff_dict, topRect;
      topRect = parentRect.copy();
      topRect.height = Math.sqrt(idealArea / ratio);
      topRect.width = ratio * topRect.height;
      if (parentRect.width - topRect.width < this.minWidth) {
        topRect.width = parentRect.width;
        topRect.height = idealArea / topRect.width;
        return {
          diff: 0.5 * pageUtils.length(remainingSets),
          pageSets: remainingSets,
          topRect: topRect
        };
      }
      if (parentRect.height - topRect.height < this.minHeight) {
        topRect.height = parentRect.height;
        topRect.width = idealArea / topRect.height;
        return {
          diff: 0,
          pageSets: [],
          topRect: topRect
        };
      }
      bottomRect = this.bottomRect(parentRect, topRect);
      diff_dict = this.diffFromIdealArea(remainingSets, bottomRect);
      diff_dict['topRect'] = topRect;
      return diff_dict;
    };

    GreedyLayout.prototype.diffFromIdealArea = function(remainingSets, bottomRect) {
      var bottomSets, closest_area;
      bottomSets = pageUtils.getOptimumSet(remainingSets, bottomRect);
      closest_area = pageUtils.idealSum(bottomSets);
      return {
        diff: Math.abs(bottomRect.area() - closest_area),
        pageSets: bottomSets
      };
    };

    GreedyLayout.prototype.bottomRect = function(parentRect, topRect) {
      return new Rect(parentRect.x, parentRect.y + topRect.height, topRect.width, parentRect.height - topRect.height);
    };

    GreedyLayout.prototype.splitPageSetsArea = function(pageSets, rect, isVertical, fix) {
      var idealSum, isFlat, page, pageRect, tmpRect, tmpRects, _i, _len;
      if (isVertical == null) {
        isVertical = true;
      }
      if (fix == null) {
        fix = true;
      }
      idealSum = pageUtils.idealSum(pageSets);
      isFlat = pageUtils.isFlat(pageSets);
      tmpRect = rect.copy();
      tmpRects = [];
      if (isFlat) {
        if (isVertical) {
          tmpRect.height = rect.height / pageSets.length;
        }
        if (!isVertical) {
          tmpRect.width = rect.width / pageSets.length;
        }
      }
      for (_i = 0, _len = pageSets.length; _i < _len; _i++) {
        page = pageSets[_i];
        if (!isFlat) {
          if (isVertical) {
            tmpRect.height = rect.height * (pageUtils.idealSum(page) / idealSum);
          }
          if (!isVertical) {
            tmpRect.width = rect.width * (pageUtils.idealSum(page) / idealSum);
          }
        }
        pageRect = tmpRect.copy();
        if (isVertical) {
          tmpRect.y += tmpRect.height;
        }
        if (!isVertical) {
          tmpRect.x += tmpRect.width;
        }
        if (!fix) {
          tmpRects.push(pageRect);
          continue;
        }
        if (pageUtils.isGroup(page)) {
          this.arrange(page, pageRect);
        } else {
          page.rect = pageRect;
        }
      }
      return tmpRects;
    };

    return GreedyLayout;

  })(Base);

  'use strict';

  this.pageUtils = {
    isGroup: function(pageSet) {
      return pageSet instanceof Array;
    },
    prioritySum: function(pageSets) {
      var i, s, _i, _ref1;
      if (!pageUtils.isGroup(pageSets)) {
        return pageSets.priority;
      }
      s = 0;
      for (i = _i = 0, _ref1 = pageSets.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        s += pageUtils.prioritySum(pageSets[i]);
      }
      return s;
    },
    length: function(pageSets) {
      var i, s, _i, _ref1;
      if (!pageUtils.isGroup(pageSets)) {
        return 1;
      }
      s = 0;
      for (i = _i = 0, _ref1 = pageSets.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        s += pageUtils.length(pageSets[i]);
      }
      return s;
    },
    avg: function(pageSets) {
      return pageUtils.prioritySum(pageSets) / pageUtils.length(pageSets);
    },
    max: function(pageSets) {
      var i, maxIndex, maxi, v, _i, _ref1;
      if (!pageUtils.isGroup(pageSets)) {
        return pageSets;
      }
      maxi = 0;
      maxIndex = 0;
      for (i = _i = 0, _ref1 = pageSets.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        v = pageUtils.avg[pageSets[i]];
        if (maxi < v) {
          maxi = v;
          maxIndex = i;
        }
      }
      return pageSets[maxIndex];
    },
    sort: function(pageSets, reverse, key) {
      if (reverse == null) {
        reverse = false;
      }
      if (key == null) {
        key = null;
      }
      if (!key) {
        key = function(a, b) {
          return pageUtils.prioritySum(a) - pageUtils.prioritySum(b);
        };
      }
      pageSets.sort(key);
      if (reverse) {
        return pageSets.reverse();
      }
    },
    idealSum: function(pageSets) {
      var i, s, _i, _ref1;
      if (!pageUtils.isGroup(pageSets)) {
        return pageSets.idealArea;
      }
      s = 0;
      for (i = _i = 0, _ref1 = pageSets.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        s += pageUtils.idealSum(pageSets[i]);
      }
      return s;
    },
    grouping: function(pageSets, range) {
      var base, group, groups, key, pageSet, pages, rectType, reverse, top;
      if (range == null) {
        range = 1.3;
      }
      pageSets = [].concat(pageSets);
      pageUtils.sort(pageSets);
      top = pageSets.pop();
      groups = [[top]];
      for (rectType in rectTypes) {
        pages = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = pageSets.length; _i < _len; _i++) {
            pageSet = pageSets[_i];
            if (pageSet.type === rectType) {
              _results.push(pageSet);
            }
          }
          return _results;
        })();
        pageUtils.sort(pages, reverse = true);
        while (pages.length > 0) {
          base = pages.pop();
          group = [base];
          if (pages.length > 0 && pages[pages.length - 1].originalPriority <= Math.ceil(base.originalPriority * range)) {
            group.push(pages.pop());
          }
          groups.push(group);
        }
      }
      pageUtils.sort(groups, reverse = true, key = function(a, b) {
        return pageUtils.avg(a) - pageUtils.avg(b);
      });
      return groups;
    },
    getOptimumSet: function(pageSets, rect) {
      var bit, i, idealSum, j, k, optimumSet, s, set, _i, _j, _ref1, _ref2;
      s = Infinity;
      optimumSet = null;
      for (i = _i = 1, _ref1 = 1 << pageSets.length; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
        bit = 0;
        j = i;
        set = [];
        idealSum = 0;
        for (k = _j = 0, _ref2 = pageSets.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; k = 0 <= _ref2 ? ++_j : --_j) {
          if (j % 2 === 1) {
            idealSum += pageUtils.idealSum(pageSets[k]);
            set.push(pageSets[k]);
            bit++;
          }
          j = j >> 1;
        }
        if (Math.abs(rect.area() - idealSum) < s && bit < 3) {
          s = Math.abs(rect.area() - idealSum);
          optimumSet = set;
        }
      }
      return optimumSet;
    },
    combination: function(pageSets, n, s, match, optimumSet) {
      var areaSum, pageSet, _i, _len, _ref1;
      if (pageSets.length < n) {
        return {
          "match": match,
          "optimumSet": optimumSet
        };
      }
      _ref1 = pageUtils.nCombination(pageSets, n);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        pageSet = _ref1[_i];
        areaSum = pageUtils.sum(pageSet, function(x) {
          return pageUtils.idealSum(x);
        });
        if (Math.abs(s - areaSum) < Math.abs(s - match)) {
          optimumSet = pageSet;
          match = areaSum;
        }
      }
      return {
        "match": match,
        "optimumSet": optimumSet
      };
    },
    nCombination: function(sets, n) {
      var c, combs, head, i, j, tailcombs, _i, _j, _ref1, _ref2;
      if (sets.length < n || n <= 0) {
        return [];
      }
      if (sets.length === n) {
        return [sets];
      }
      if (n === 1) {
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = sets.length; _i < _len; _i++) {
            c = sets[_i];
            _results.push(c);
          }
          return _results;
        })();
      }
      combs = [];
      for (i = _i = 0, _ref1 = sets.length - n + 1; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        head = sets.slice(i, i + 1);
        tailcombs = pageUtils.nCombination(sets.slice(i + 1), n - 1);
        for (j = _j = 0, _ref2 = tailcombs.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
          combs.push(head.concat(tailcombs[j]));
        }
      }
      return combs;
    },
    deformPriorities: function(pageSets, area, min_width, min_height) {
      var areaMin, page, pageSet, prioritySum, x, _i, _len, _results;
      prioritySum = pageUtils.prioritySum(pageSets);
      areaMin = min_height * min_height;
      x = (area / areaMin) / prioritySum;
      _results = [];
      for (_i = 0, _len = pageSets.length; _i < _len; _i++) {
        pageSet = pageSets[_i];
        if (pageUtils.isGroup(pageSet)) {
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = pageSet.length; _j < _len1; _j++) {
              page = pageSet[_j];
              _results1.push(page.priority = Math.ceil(x * page.priority));
            }
            return _results1;
          })());
        } else {
          _results.push(pageSet.priority = Math.ceil(x * pageSet.priority));
        }
      }
      return _results;
    },
    debug: function(pageSets) {
      var pageSet;
      if (!pageUtils.isGroup(pageSets)) {
        return pageSets.priority;
      }
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = pageSets.length; _i < _len; _i++) {
          pageSet = pageSets[_i];
          _results.push(pageUtils.debug(pageSet));
        }
        return _results;
      })();
    },
    diffRatio: function(rect, rectType, align) {
      var minRatio, ratio, t, _i, _len, _ref1;
      if (align == null) {
        align = 0;
      }
      minRatio = 10000;
      _ref1 = rectTypes[rectType];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        t = _ref1[_i];
        if (align > 0 && align < t.minAlign) {
          continue;
        }
        ratio = rect.width / rect.height;
        minRatio = Math.min(minRatio, t.ratio < ratio ? ratio / t.ratio : t.ratio / ratio);
      }
      return minRatio;
    },
    isFlat: function(pageSets) {
      var page, _i, _len;
      for (_i = 0, _len = pageSets.length; _i < _len; _i++) {
        page = pageSets[_i];
        if (pageUtils.isGroup(page)) {
          return false;
        }
      }
      return true;
    },
    sum: function(array, f) {
      var a, s, _i, _len;
      if (f == null) {
        f = null;
      }
      if (!f) {
        f = function(x) {
          return x;
        };
      }
      s = 0;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        a = array[_i];
        s += f(a);
      }
      return s;
    }
  };

  RectType = (function() {
    function RectType(ratio, minAlign) {
      this.ratio = ratio;
      this.minAlign = minAlign != null ? minAlign : 1;
    }

    return RectType;

  })();

  this.rectTypes = {
    'image': [new RectType(0.9, 1), new RectType(1.6, 1), new RectType(3.0, 2), new RectType(3.8, 2)],
    'text': [new RectType(3.8, 1), new RectType(1.0, 1)]
  };

}).call(this);
